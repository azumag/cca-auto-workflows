name: Issue Processor

on:
  issues:
    types: [labeled]

jobs:
  process-issue:
    name: Process Issue and Create PR
    runs-on: ubuntu-latest
    
    if: |
      (github.event.action == 'labeled' && github.event.label.name == 'processing')
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 1


           
      - name: Run Claude Code for Issue Implementation
        id: claude
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          
          additional_permissions: |
            actions: read

          allowed_tools: "Agent,Bash,Edit,MultiEdit,WebFetch,WebSearch,Write"
          
          direct_prompt: |
            ã“ã®Issue #${{ github.event.issue.number }} ã‚’è§£æ±ºã—ã¦ãã ã•ã„ã€‚
            
            **ã‚¿ã‚¤ãƒˆãƒ«**: ${{ github.event.issue.title }}
            
            **èª¬æ˜**:
            ${{ github.event.issue.body || 'èª¬æ˜ãªã—' }}
            
            ä»¥ä¸‹ã®ç‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š
            - Issue ã®å†…å®¹ã‚’ç†è§£ã—ã€å¿…è¦ãªå®Ÿè£…ã‚’è¡Œã£ã¦ãã ã•ã„
            - å®Ÿè£…ãŒå®Œäº†ã—ãŸã‚‰ã€å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆã—ã¦ãã ã•ã„
            - å®Ÿè£…ãŒå®Œäº†ã—ã€ãƒ†ã‚¹ãƒˆã‚‚é€šã£ãŸå ´åˆã¯ã€'pr-ready' ãƒ©ãƒ™ãƒ«ã‚’ã“ã®Issueã«è¿½åŠ ã—ã¦ãã ã•ã„
            - è§£æ±ºæ¸ˆã¿ã®å ´åˆã¯ã€'resolved' ãƒ©ãƒ™ãƒ«ã‚’ã¤ã‘ã¦Issueã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¦ãã ã•ã„
            - å®Ÿè£…ã§ããªã„å ´åˆã¯ã€ç†ç”±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§èª¬æ˜ã—ã¦ãã ã•ã„
            - PRä½œæˆãƒªãƒ³ã‚¯ã‚’æä¾›ã—ã¦ãã ã•ã„

      - name: Remove processing label and run Claude
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const issueNumber = context.payload.issue.number;
            
            // processing ãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                name: 'processing'
              });
              console.log('Removed processing label');
            } catch (error) {
              console.log('processing label not found or already removed');
            }

      - name: Check if pr-ready label exists and create PR
        id: check-pr-ready
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const issueNumber = context.payload.issue.number;
            
            // Issue ã®ç¾åœ¨ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const hasPrReadyLabel = issue.data.labels.some(label => label.name === 'pr-ready');
            
            if (!hasPrReadyLabel) {
              console.log('pr-ready label not found, skipping PR creation');
              return;
            }
            
            console.log('pr-ready label found, proceeding to create PR');
            
            // pr-ready ãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                name: 'pr-ready'
              });
              console.log('Removed pr-ready label');
            } catch (error) {
              console.log('pr-ready label removal failed:', error);
            }
            
            // GitHub App Token ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã«æƒ…å ±ã‚’æ¸¡ã™
            core.setOutput('create_pr', 'true');
            core.setOutput('issue_number', issueNumber);
            core.setOutput('issue_title', issue.data.title);

      - name: Generate GitHub App Token
        if: always() && steps.check-pr-ready.outputs.create_pr == 'true'
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Create Pull Request
        if: always() && steps.check-pr-ready.outputs.create_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const issueNumber = ${{ steps.check-pr-ready.outputs.issue_number }};
            const issueTitle = `${{ steps.check-pr-ready.outputs.issue_title }}`;
            
            try {
              // Issueã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–å¾—ã—ã¦ã€Create PRãƒªãƒ³ã‚¯ã‚’æ¢ã™
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              // æœ€æ–°ã®ã‚³ãƒ¡ãƒ³ãƒˆã‹ã‚‰Create PRãƒªãƒ³ã‚¯ã‚’æ¤œç´¢
              let prUrl = null;
              console.log(`Found ${comments.data.length} comments`);
              
              for (const comment of comments.data.reverse()) {
                console.log(`Checking comment: ${comment.body.substring(0, 100)}...`);
                
                // è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ãƒãƒƒãƒã‚’è©¦è¡Œ
                const patterns = [
                  /\[Create PR\]\((https:\/\/github\.com\/[^\/\s]+\/[^\/\s]+\/compare\/[^\s)]+)\)/,
                  /https:\/\/github\.com\/[^\/\s]+\/[^\/\s]+\/compare\/[^\s)]+/g
                ];
                
                for (const pattern of patterns) {
                  const matches = comment.body.match(pattern);
                  if (matches) {
                    console.log(`Found match with pattern: ${pattern}`);
                    console.log(`Matches: ${JSON.stringify(matches)}`);
                    // URLã®ã¿ã‚’æŠ½å‡ºï¼ˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒªãƒ³ã‚¯ã®å ´åˆã¯æ‹¬å¼§å†…ã®URLï¼‰
                    prUrl = matches[0].includes('[Create PR]') ? matches[1] : matches[0];
                    console.log(`Extracted PR URL: ${prUrl}`);
                    break;
                  }
                }
                
                if (prUrl) break;
              }
              
              if (prUrl) {
                // GitHub Compare URLã‚’è§£æã™ã‚‹é–¢æ•°
                function parseCompareUrl(url) {
                  try {
                    console.log('Parsing URL:', url);
                    const urlObj = new URL(url);
                    console.log('URL pathname:', urlObj.pathname);
                    
                    // ãƒ‘ã‚¹åã‹ã‚‰ /compare/base...head ã®éƒ¨åˆ†ã‚’æŠ½å‡º
                    const pathMatch = urlObj.pathname.match(/\/compare\/(.+)\.\.\.(.+)/);
                    if (!pathMatch) {
                      console.error('Path match failed for:', urlObj.pathname);
                      return null;
                    }
                    
                    console.log('Base:', pathMatch[1], 'Head:', pathMatch[2]);
                    
                    return {
                      base: pathMatch[1],
                      head: pathMatch[2],
                      title: urlObj.searchParams.get('title'),
                      body: urlObj.searchParams.get('body')
                    };
                  } catch (error) {
                    console.error('URL parsing error:', error);
                    return null;
                  }
                }
                
                // URLã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡º
                console.log('Found URL:', prUrl);
                const prInfo = parseCompareUrl(prUrl);
                console.log('Parsed info:', JSON.stringify(prInfo, null, 2));
                if (!prInfo) throw new Error('Invalid URL format');
                
                // ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆ
                const pr = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: prInfo.title || `Fix: ${issueTitle}`,
                  body: prInfo.body || `Fixes #${issueNumber}\n\nAuto-generated PR to resolve issue.`,
                  head: prInfo.head,
                  base: prInfo.base
                });
                  
                  // Issue ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: `PR created: ${pr.data.html_url}`
                  });
                  
                  // pr-created ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: ['pr-created']
                  });
                  
                  console.log(`PR created: ${pr.data.html_url}`);
                } else {
                  throw new Error('Invalid PR URL format');
                }
              } else {
                throw new Error('Create PR link not found in comments');
              }
              
            } catch (error) {
              console.error('PR creation error:', error);
              
              // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
              let errorMessage = error.message;
              let shouldCloseIssue = false;
              
              // GitHub API ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æ
              if (error.status === 422 && error.response?.data?.errors) {
                const errors = error.response.data.errors;
                console.log('Validation errors:', JSON.stringify(errors, null, 2));
                
                // headãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®invalidã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
                const headError = errors.find(err => 
                  err.resource === 'PullRequest' && 
                  err.field === 'head' && 
                  err.code === 'invalid'
                );
                
                if (headError) {
                  shouldCloseIssue = true;
                  errorMessage = `Invalid head branch: ${headError.message || 'Branch does not exist or is not accessible'}`;
                }
              }
              
              // ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `âŒ Error: ${errorMessage}${shouldCloseIssue ? '\n\nğŸ”’ Auto-closing issue due to invalid branch reference.' : ''}`
              });
            }